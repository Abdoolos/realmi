// Agent SDK for AI Assistant functionality
// This is a mock implementation that provides the interface used by the AI components

class AgentSDK {
  constructor() {
    this.conversations = new Map();
    this.subscribers = new Map();
    this.messageId = 0;
  }

  // Create a new conversation
  async createConversation(config) {
    const conversationId = `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const conversation = {
      id: conversationId,
      agent_name: config.agent_name || "FinancialAssistant",
      metadata: config.metadata || {},
      messages: [],
      created_date: new Date().toISOString(),
      updated_date: new Date().toISOString(),
      status: 'active'
    };

    this.conversations.set(conversationId, conversation);
    
    // Store in localStorage for persistence
    this.saveConversationsToStorage();
    
    return conversation;
  }

  // List conversations for a specific agent
  async listConversations(filter = {}) {
    const conversations = Array.from(this.conversations.values());
    
    if (filter.agent_name) {
      return conversations.filter(conv => conv.agent_name === filter.agent_name);
    }
    
    return conversations;
  }

  // Add a message to a conversation
  async addMessage(conversation, message) {
    if (!conversation || !conversation.id) {
      throw new Error('Invalid conversation');
    }

    const messageWithId = {
      ...message,
      id: ++this.messageId,
      timestamp: new Date().toISOString()
    };

    const conv = this.conversations.get(conversation.id);
    if (conv) {
      conv.messages.push(messageWithId);
      conv.updated_date = new Date().toISOString();
      
      // Save to storage
      this.saveConversationsToStorage();
      
      // Notify subscribers
      this.notifySubscribers(conversation.id, conv);
      
      // If it's a user message, generate AI response
      if (message.role === 'user') {
        // Check if it's a FAQ question - respond immediately
        this.checkAndRespond(conversation, message.content);
      }
    }

    return messageWithId;
  }

  // Subscribe to conversation updates
  subscribeToConversation(conversationId, callback) {
    if (!this.subscribers.has(conversationId)) {
      this.subscribers.set(conversationId, new Set());
    }
    
    this.subscribers.get(conversationId).add(callback);
    
    // Return unsubscribe function
    return () => {
      const subs = this.subscribers.get(conversationId);
      if (subs) {
        subs.delete(callback);
        if (subs.size === 0) {
          this.subscribers.delete(conversationId);
        }
      }
    };
  }

  // Notify all subscribers of a conversation
  notifySubscribers(conversationId, conversationData) {
    const subscribers = this.subscribers.get(conversationId);
    if (subscribers) {
      subscribers.forEach(callback => {
        try {
          callback(conversationData);
        } catch (error) {
          console.error('Error in conversation subscriber:', error);
        }
      });
    }
  }

  // Check message type and respond immediately
  async checkAndRespond(conversation, userMessage) {
    // Respond immediately without any delay
    await this.generateAIResponse(conversation, userMessage);
  }

  // Generate AI response (mock implementation)
  async generateAIResponse(conversation, userMessage) {
    const conv = this.conversations.get(conversation.id);
    if (!conv) return;

    // Simple response generation based on keywords
    let response = await this.generateResponseBasedOnMessage(userMessage);

    const aiMessage = {
      id: ++this.messageId,
      role: 'assistant',
      content: response,
      timestamp: new Date().toISOString()
    };

    conv.messages.push(aiMessage);
    conv.updated_date = new Date().toISOString();
    
    // Force immediate update
    this.saveConversationsToStorage();
    
    // Notify subscribers immediately with a fresh copy
    this.notifySubscribers(conversation.id, { ...conv, messages: [...conv.messages] });
    
    // Force another notification to ensure UI updates
    setTimeout(() => {
      this.notifySubscribers(conversation.id, { ...conv, messages: [...conv.messages] });
    }, 10);
  }

  // Generate response based on user message content using enhanced knowledge base
  async generateResponseBasedOnMessage(message) {
    // Import knowledge base dynamically
    const { 
      analyzeIntent, 
      getPageInfo, 
      MENU_INFO, 
      API_ROUTES, 
      APP_INFO, 
      FINANCIAL_TIPS,
      getAllFAQs,
      getFAQsByCategory,
      getFAQCategories,
      searchFAQs
    } = await import('./knowledgeBase.js');
    
    const lowerMessage = message.toLowerCase();
    const intent = analyzeIntent(message);
    
    // Handle FAQ requests first
    if (lowerMessage.includes('ุฃุณุฆูุฉ') || lowerMessage.includes('ุณุคุงู') || lowerMessage.includes('ุงุณุชูุณุงุฑ') || lowerMessage.includes('faq')) {
      const categories = getFAQCategories();
      return `โ **ุงูุฃุณุฆูุฉ ุงูุดุงุฆุนุฉ - FAQ**\n\n**ุงููุฆุงุช ุงููุชููุฑุฉ:**\n\n${categories.map(cat => 
        `${cat.icon} **${cat.name}** (${cat.count} ุฃุณุฆูุฉ)`
      ).join('\n')}\n\n๐ก **ููุจุญุซ ุนู ุณุคุงู ูุญุฏุฏ:**\nโข ูู "ุงุจุญุซ ุนู [ูููุฉ ุงูุจุญุซ]"\nโข ุฃู ุงุณุฃู ุณุคุงูู ูุจุงุดุฑุฉ\n\n**ุฃูุซูุฉ:**\nโข "ูู ุงูุชุทุจูู ูุฌุงููุ"\nโข "ููู ุฃุณุชุฎุฏู ุงูุชุทุจููุ"\nโข "ูู ุจูุงูุงุชู ุขููุฉุ"`;
    }
    
    // First: Try exact match with FAQ questions
    const allFAQs = getAllFAQs();
    const exactMatch = allFAQs.find(faq => 
      faq.question.trim() === message.trim() ||
      faq.question.toLowerCase().trim() === lowerMessage.trim()
    );
    
    if (exactMatch) {
      let response = `${exactMatch.categoryIcon} **${exactMatch.question}**\n\n${exactMatch.answer}`;
      
      // Find similar questions in the same category
      const similarInCategory = allFAQs.filter(faq => 
        faq.category === exactMatch.category && faq.id !== exactMatch.id
      ).slice(0, 2);
      
      if (similarInCategory.length > 0) {
        response += `\n\n**ุฃุณุฆูุฉ ุฃุฎุฑู ูู ููุณ ุงููุฆุฉ:**\n${similarInCategory.map(faq => 
          `โข ${faq.question}`
        ).join('\n')}`;
      }
      
      return response;
    }
    
    // Second: Search in FAQs if the message looks like a question
    if (lowerMessage.includes('ูู') || lowerMessage.includes('ููู') || lowerMessage.includes('ูุงุฐุง') || 
        lowerMessage.includes('ูุด') || lowerMessage.includes('ุงูุด') || lowerMessage.includes('ุ')) {
      const searchResults = searchFAQs(message);
      if (searchResults.length > 0) {
        const topResult = searchResults[0];
        let response = `${topResult.categoryIcon} **${topResult.question}**\n\n${topResult.answer}`;
        
        if (searchResults.length > 1) {
          response += `\n\n**ุฃุณุฆูุฉ ูุดุงุจูุฉ:**\n${searchResults.slice(1, 3).map(faq => 
            `โข ${faq.question}`
          ).join('\n')}`;
        }
        
        return response;
      }
    }
    
    // Handle category-specific FAQ requests
    const categories = getFAQCategories();
    for (const cat of categories) {
      if (lowerMessage.includes(cat.name.toLowerCase())) {
        const categoryFAQs = getFAQsByCategory(cat.name);
        return `${cat.icon} **${cat.name}** (${cat.count} ุฃุณุฆูุฉ)\n\n${categoryFAQs.map(faq => 
          `**ุณ${faq.id}: ${faq.question}**\n${faq.answer}\n`
        ).join('\n---\n\n')}`;
      }
    }
    
    // Handle navigation requests
    if (intent.intent === 'navigate' && intent.target) {
      const pageInfo = getPageInfo(intent.target);
      if (pageInfo) {
        return `๐งญ **${pageInfo.title}**\n\n๐ ${pageInfo.description}\n\n**ุงูููุฒุงุช ุงููุชุงุญุฉ:**\n${pageInfo.features.map(f => `โข ${f}`).join('\n')}\n\n๐ก **ููููุฉ ุงูุงุณุชุฎุฏุงู:**\n${pageInfo.howToUse}\n\n๐ [ุงูุชูู ุฅูู ${pageInfo.title}](${intent.target})`;
      }
    }
    
    // Handle expense addition
    if (intent.intent === 'add_expense') {
      if (intent.amount && intent.category) {
        // Try to add expense via API
        try {
          await this.addExpenseToAPI(intent.amount, intent.category, message);
          return `โ **ุชู ุชุณุฌูู ุงููุตุฑูู ุจูุฌุงุญ!**\n\n๐ฐ ุงููุจูุบ: ${intent.amount} ุฑูุงู\n๐ท๏ธ ุงููุฆุฉ: ${intent.category}\n\n๐ ุชู ุฅุถุงูุฉ ุงููุตุฑูู ุฅูู ุญุณุงุจู ูุณูุธูุฑ ูู ุงูุชูุงุฑูุฑ.\n\n๐ก **ูุตูุญุฉ**: ููููู ุนุฑุถ ุฌููุน ูุตุงุฑููู ูู [ูุงุฆูุฉ ุงููุตุงุฑูู](/expenses-list)`;
        } catch (error) {
          return `โ **ุชู ููู ุทูุจู ูุฅุถุงูุฉ ูุตุฑูู**\n\n๐ฐ ุงููุจูุบ: ${intent.amount} ุฑูุงู\n๐ท๏ธ ุงููุฆุฉ: ${intent.category}\n\n๐ ูุฅููุงู ุฅุถุงูุฉ ุงููุตุฑููุ ุชูุฌู ุฅูู [ุตูุญุฉ ุฅุถุงูุฉ ูุตุฑูู](/add-expense)\n\n๐ก ุฃู ููููู ููู "ุงูุชูู ุฅูู ุฅุถุงูุฉ ูุตุฑูู" ูุณุฃูุฌูู ููุงู.`;
        }
      } else {
        return `๐ฐ **ุฃุฑูุฏ ูุณุงุนุฏุชู ูู ุชุณุฌูู ุงููุตุฑูู!**\n\n๐ค ูุจุฏู ุฃูู ุชุฑูุฏ ุฅุถุงูุฉ ูุตุฑููุ ููู ุฃุญุชุงุฌ ูุนูููุงุช ุฃูุซุฑ:\n\n**ุงููุทููุจ:**\nโข ุงููุจูุบ (ูุซู: 50 ุฑูุงู)\nโข ุงููุฆุฉ (ูุซู: ุทุนุงูุ ููุงุตูุงุช)\n\n**ุฃูุซูุฉ:**\nโข "ุตุฑูุช 75 ุฑูุงู ุนูู ุทุนุงู"\nโข "ุงุดุชุฑูุช ุจูุฒูู ุจู 100 ุฑูุงู"\nโข "ุฏูุนุช 25 ุฑูุงู ุชุงูุณู"\n\n๐ ุฃู ููููู ุงูุฐูุงุจ ูุจุงุดุฑุฉ ุฅูู [ุตูุญุฉ ุฅุถุงูุฉ ูุตุฑูู](/add-expense)`;
      }
    }
    
    // Handle data queries
    if (intent.intent === 'query_data') {
      try {
        const reportData = await this.getReportData(intent.type);
        return this.formatReportResponse(reportData, intent.type);
      } catch (error) {
        return `๐ **ุชูุฑูุฑ ูุตุงุฑููู**\n\n๐ ูููููู ูุณุงุนุฏุชู ูู ุนุฑุถ:\n\n๐ **ุงูุชูุฑูุฑ ุงูุดูุฑู**: ูุงูู ุจุงูุฑุณูู ุงูุจูุงููุฉ\n๐ **ุงูุฅุญุตุงุฆูุงุช**: ุชุญููู ุนุงุฏุงุช ุงูุฅููุงู\n๐จโ๐ฉโ๐งโ๐ฆ **ุชูุฑูุฑ ุงูุนุงุฆูุฉ**: ุฅุฐุง ููุช ูู ุนุงุฆูุฉ\n\n๐ **ุฑูุงุจุท ุณุฑูุนุฉ:**\nโข [ุงูุชูุฑูุฑ ุงูุดูุฑู](/monthly-report)\nโข [ุงูุฅุญุตุงุฆูุงุช](/analytics)\nโข [ุชูุฑูุฑ ุงูุนุงุฆูุฉ](/family-report)\n\nุฃู ูู "ุงูุชูู ุฅูู ุงูุชูุฑูุฑ ุงูุดูุฑู" ูุณุฃูุฌูู ููุงู.`;
      }
    }
    
    // Handle general app information requests
    if (lowerMessage.includes('ูุณุงุนุฏุฉ') || lowerMessage.includes('ุฃููุง') || lowerMessage.includes('ูุฑุญุจุง') || lowerMessage.includes('help')) {
      return `๐ **ุฃููุงู ูุณููุงู ูู ${APP_INFO.name}!**\n\n๐ค ุฃูุง ุงููุณุงุนุฏ ุงูุฐูู ููุณุงุนุฏุชู ูู ุฅุฏุงุฑุฉ ุฃููุงูู.\n\n**ูููููู ูุณุงุนุฏุชู ูู:**\n\n๐ฐ **ุฅุถุงูุฉ ุงููุตุงุฑูู**: "ุตุฑูุช 50 ุฑูุงู ุทุนุงู"\n๐ **ุนุฑุถ ุงูุชูุงุฑูุฑ**: "ูู ุตุฑูุช ูุฐุง ุงูุดูุฑุ"\n๐ฏ **ุฅุฏุงุฑุฉ ุงูููุฒุงููุงุช**: "ุถุน ููุฒุงููุฉ ููุทุนุงู 500 ุฑูุงู"\n๐งญ **ุงูุชููู**: "ุงูุชูู ุฅูู ูุงุฆูุฉ ุงููุตุงุฑูู"\n๐ก **ุงููุตุงุฆุญ ุงููุงููุฉ**: "ุฃุนุทูู ูุตุงุฆุญ ููุงุฏุฎุงุฑ"\n\n**ุงูููุงุฆู ุงููุชุงุญุฉ:**\n${Object.values(MENU_INFO).slice(0, 5).map(info => `โข ${info.title}`).join('\n')}\n\n๐ฌ **ุฌุฑุจ ููู:** "ุงุนุฑุถ ุงูููุงุฆู ุงููุชุงุญุฉ" ูุฑุคูุฉ ุฌููุน ุงููุธุงุฆู`;
    }
    
    // Handle menu listing
    if (lowerMessage.includes('ููุงุฆู') || lowerMessage.includes('ูุธุงุฆู') || lowerMessage.includes('ููุฒุงุช')) {
      return `๐ **ุงูููุงุฆู ูุงููุธุงุฆู ุงููุชุงุญุฉ ูู ${APP_INFO.name}:**\n\n${Object.entries(MENU_INFO).map(([route, info]) => 
        `๐น **${info.title}**\n   ${info.description}\n   ๐ฌ ${info.quickPhrase || 'ูู "ุงูุชูู ุฅูู ' + info.title + '"'}\n`
      ).join('\n')}\n\n๐ก **ูุงุณุชุฎุฏุงู ุฃู ูุธููุฉ:** ุงุฐูุฑ ุงุณููุง ุฃู ูู "ุงูุชูู ุฅูู [ุงุณู ุงููุธููุฉ]"`;
    }
    
    // Handle financial tips requests
    if (lowerMessage.includes('ูุตุงุฆุญ') || lowerMessage.includes('ูุตูุญุฉ')) {
      const randomTip = FINANCIAL_TIPS[Math.floor(Math.random() * FINANCIAL_TIPS.length)];
      const randomTipText = randomTip.tips[Math.floor(Math.random() * randomTip.tips.length)];
      return `๐ก **ูุตูุญุฉ ูุงููุฉ ุฐููุฉ - ${randomTip.category}:**\n\n"${randomTipText}"\n\n๐ **ุงููุฒูุฏ ูู ุงููุตุงุฆุญ ุญูู ${randomTip.category}:**\n${randomTip.tips.filter(tip => tip !== randomTipText).slice(0, 2).map(tip => `โข ${tip}`).join('\n')}\n\n๐ฏ **ูู ุชุฑูุฏ ูุตุงุฆุญ ูู ููุถูุน ูุนููุ** ูู "ูุตุงุฆุญ ููุงุฏุฎุงุฑ" ุฃู "ูุตุงุฆุญ ููููุฒุงููุฉ"`;
    }
    
    // Default response with developer credit
    return `๐ค **ุดูุฑุงู ูุชูุงุตูู ูุนู!**\n\nุฃูุง ุงููุณุงุนุฏ ุงููุงูู ุงูุฐูู ูู ${APP_INFO.name}.\n\n**ูููููู ูุณุงุนุฏุชู ูู:**\n\n๐ฐ **ุงููุตุงุฑูู**: "ุตุฑูุช 50 ุฑูุงู ุนูู ุทุนุงู"\n๐ **ุงูุชูุงุฑูุฑ**: "ุงุนุฑุถ ููุฎุต ูุฐุง ุงูุดูุฑ"\n๐งญ **ุงูุชููู**: "ุงูุชูู ุฅูู ูุงุฆูุฉ ุงููุตุงุฑูู"\n๐ก **ุงููุตุงุฆุญ**: "ุฃุนุทูู ูุตุงุฆุญ ูุงููุฉ"\n\n**ุฃูุซูุฉ ุฃุฎุฑู:**\nโข "ูู ุตุฑูุช ุนูู ุงูุทุนุงูุ"\nโข "ุถุน ููุฒุงููุฉ 800 ุฑูุงู ููููุงุตูุงุช"\nโข "ุงุนุฑุถ ุงูููุงุฆู ุงููุชุงุญุฉ"\n\n๐ฌ **ูุง ุงูุฐู ุชุฑูุฏ ูุณุงุนุฏุฉ ูููุ**`;
  }
  
  // Add expense to API
  async addExpenseToAPI(amount, category, description) {
    const expenseData = {
      amount: amount,
      category: category,
      description: description,
      date: new Date().toISOString(),
      currency: 'SAR'
    };
    
    const response = await fetch('/api/expenses', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(expenseData)
    });
    
    if (!response.ok) {
      throw new Error('Failed to add expense');
    }
    
    return await response.json();
  }
  
  // Get report data
  async getReportData(type = 'general') {
    const response = await fetch('/api/reports');
    if (!response.ok) {
      throw new Error('Failed to get report data');
    }
    return await response.json();
  }
  
  // Format report response
  formatReportResponse(data, type) {
    if (!data) {
      return `๐ **ุชูุฑูุฑ ูุตุงุฑููู**\n\nูุง ุชูุฌุฏ ุจูุงูุงุช ูุชุงุญุฉ ุญุงููุงู.\n\n๐ [ุงุจุฏุฃ ุจุฅุถุงูุฉ ูุตุฑูู](/add-expense)`;
    }
    
    return `๐ **ููุฎุต ูุตุงุฑููู:**\n\n๐ฐ **ุงูุฅุฌูุงูู**: ${data.total || 0} ุฑูุงู\n๐ **ูุฐุง ุงูุดูุฑ**: ${data.monthly || 0} ุฑูุงู\n\n๐ **ููุฒูุฏ ูู ุงูุชูุงุตูู:**\nโข [ุงูุชูุฑูุฑ ุงูุดูุฑู ุงููุงูู](/monthly-report)\nโข [ุงูุฅุญุตุงุฆูุงุช ุงูุชูุตูููุฉ](/analytics)`;
  }

  // Save conversations to localStorage for persistence
  saveConversationsToStorage() {
    try {
      const conversationsArray = Array.from(this.conversations.entries());
      localStorage.setItem('ai_conversations', JSON.stringify(conversationsArray));
    } catch (error) {
      console.error('Error saving conversations to storage:', error);
    }
  }

  // Load conversations from localStorage
  loadConversationsFromStorage() {
    try {
      // Check if localStorage is available (client-side only)
      if (typeof window !== 'undefined' && window.localStorage) {
        const stored = localStorage.getItem('ai_conversations');
        if (stored) {
          const conversationsArray = JSON.parse(stored);
          this.conversations = new Map(conversationsArray);
          
          // Set messageId to highest existing message id + 1
          let maxMessageId = 0;
          for (const [, conversation] of this.conversations) {
            if (conversation.messages) {
              for (const message of conversation.messages) {
                if (message.id && message.id > maxMessageId) {
                  maxMessageId = message.id;
                }
              }
            }
          }
          this.messageId = maxMessageId;
        }
      }
    } catch (error) {
      console.error('Error loading conversations from storage:', error);
    }
  }

  // Initialize the SDK
  initialize() {
    this.loadConversationsFromStorage();
  }
}

// Create and initialize the singleton instance
const agentSDK = new AgentSDK();
agentSDK.initialize();

export { agentSDK };
export default agentSDK;
